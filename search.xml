<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>一个简单的Http服务器</title>
      <link href="/2019/06/25/yi-ge-jian-yi-de-http-fu-wu-qi/"/>
      <url>/2019/06/25/yi-ge-jian-yi-de-http-fu-wu-qi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>HTTP协议广泛应用于互联网，与我们的日常生活息息相关。通过实现一个简单的HTTP服务器，可以对其有更加深刻的认识。</p></blockquote><h1 id="1-HTTP服务器总览"><a href="#1-HTTP服务器总览" class="headerlink" title="1.HTTP服务器总览"></a>1.HTTP服务器总览</h1><p>HTTP服务器<strong>实现了HTTP和相关的TCP连接处理，负责管理Web服务器提供的资源</strong>。HTTP服务器逻辑和操作系统共同负责管理TCP连接。操作系统管理底层计算机系统的硬件细节，并提供了TCP/IP网络支持、负责装载Web资源的文件系统以及控制当前计算活动的进程管理。<br>HTTP服务器的功能：</p><ul><li><code>建立连接</code>——接受一个客户端连接。</li><li><code>接收请求</code>——从网络中读取一条HTTP请求报文。</li><li><code>处理请求</code>——对请求报文进行解释，并采取行动。</li><li><code>访问资源</code>——访问报文中指定的资源。</li><li><code>构建响应</code>——创建带有正确首部的HTTP响应报文</li><li><code>发送响应</code>——将响应回送给客户端</li><li><code>记录事务处理过程</code>——将与已完成事务有关的内容记录在日志文件中。<br><div align="center/"><img src="https://test-1258680748.cos.ap-shanghai.myqcloud.com/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84HTTP%E6%9C%8D%E5%8A%A1%E5%99%A8/1.PNG" alt="" title="基本HTTP服务器请求的步骤"></div></li></ul><h1 id="2-HTTP请求响应处理流程及实现"><a href="#2-HTTP请求响应处理流程及实现" class="headerlink" title="2.HTTP请求响应处理流程及实现"></a>2.HTTP请求响应处理流程及实现</h1><h3 id="2-1-接受客户端连接"><a href="#2-1-接受客户端连接" class="headerlink" title="2.1 接受客户端连接"></a>2.1 接受客户端连接</h3><p>客户端的HTTP请求报文是通过与服务器之间的TCP连接传输的，所以要先建立一条客户端和服务器之间的TCP连接。首先服务器端要通过<code>ServerSocket</code>在指定端口进行监听，服务器端阻塞在accept()处直至有客户端与其相连：</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">int</span> port <span class="token operator">=</span> <span class="token number">8080</span><span class="token punctuation">;</span>    ServerSocket serverSocket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerSocket</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        Socket socket <span class="token operator">=</span> serverSocket<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="2-2-接收请求报文"><a href="#2-2-接收请求报文" class="headerlink" title="2.2 接收请求报文"></a>2.2 接收请求报文</h3><p>服务器和客户端之间的连接上有数据到达服务器时，HTTP服务器会从连接中读取数据，并将请求报文中的内容解析出来。解析请求报文时，HTTP服务器会：</p><ul><li>解析请求行，查找请求方法、指定的资源标识符（URI）以及HTTP协议版本号，各项间由一个空格分隔，并以一个回车换行（CRLF）序列作为行的结束；</li><li>读取以CRLF结尾的报文首部；</li><li>检测到以CRLF结尾的、标示首部结束的空行；</li><li>如果有请求体（长度由Content-Length首部指定），读取请求体。</li></ul><pre class=" language-java"><code class="language-java">    InputStream socketIn<span class="token operator">=</span>socket<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buffer<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    socketIn<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>    String request<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//获取HTTP请求的第一行</span>    String firstLineOfRequest<span class="token operator">=</span>request<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>request<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//解析HTTP请求的第一行</span>    String<span class="token punctuation">[</span><span class="token punctuation">]</span> parts<span class="token operator">=</span>firstLineOfRequest<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//获取HTTP请求中的URI</span>    String uri<span class="token operator">=</span>parts<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><h3 id="2-3-处理请求"><a href="#2-3-处理请求" class="headerlink" title="2.3 处理请求"></a>2.3 处理请求</h3><p>一旦HTTP服务器接收到了请求，就可以根据方法、资源、首部和可选的主体部分来对请求进行处理。有些方法（比如POST）要求请求报文中必须带有请求体；而有些方法比如（GET）禁止在请求报文中包含请求体</p><h3 id="2-4-对资源的映射及访问"><a href="#2-4-对资源的映射及访问" class="headerlink" title="2.4 对资源的映射及访问"></a>2.4 对资源的映射及访问</h3><p>HTTP服务器是资源服务器，它们负责发送预先创建好的内容（比如HTML页面或JPEG图片）以及运行在服务器上的资源生成程序所产生的动态内容。</p><pre class=" language-java"><code class="language-java">    InputStream in<span class="token operator">=</span>HTTPServer<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span><span class="token string">"/server"</span><span class="token operator">+</span>uri<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="2-5-构建响应"><a href="#2-5-构建响应" class="headerlink" title="2.5 构建响应"></a>2.5 构建响应</h3><p>当HTTP服务器识别出了资源，就执行请求方法中描述的动作，并返回响应报文。响应报文中包含有相应状态码、响应首部，如果有响应体的话，还包括响应体。</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/*决定HTTP响应正文的类型*/</span>    String contentType<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>uri<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"html"</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">||</span>uri<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"htm"</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        contentType<span class="token operator">=</span><span class="token string">"text/html"</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>uri<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"jpg"</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">||</span>uri<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"jpeg"</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        contentType<span class="token operator">=</span><span class="token string">"image/jpeg"</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>uri<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"gif"</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        contentType<span class="token operator">=</span><span class="token string">"image/gif"</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        contentType<span class="token operator">=</span><span class="token string">"application/octet-stream"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*创建HTTP响应结果*/</span>    <span class="token comment" spellcheck="true">//HTTP响应的第一行</span>    String responseFirstLine<span class="token operator">=</span><span class="token string">"HTTP/1.1 200 OK\r\n"</span><span class="token punctuation">;</span>    String responseHeader<span class="token operator">=</span><span class="token string">"Content-type:"</span><span class="token operator">+</span>contentType<span class="token operator">+</span><span class="token string">"\r\n\r\n"</span><span class="token punctuation">;</span></code></pre><h3 id="2-6-发送响应"><a href="#2-6-发送响应" class="headerlink" title="2.6 发送响应"></a>2.6 发送响应</h3><p>HTTP服务器要记录连接的状态，还要注意对持久连接的处理。对于非持久连接而言，服务器应该在发送了整条报文之后，关闭自己这一端的连接。</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">//发送HTTP响应结果</span>    OutputStream socketOut<span class="token operator">=</span>socket<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    socketOut<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>responseFirstLine<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    socketOut<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>responseHeader<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//发送正文</span>    <span class="token keyword">int</span> len<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    buffer<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">128</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>len<span class="token operator">=</span>in<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        socketOut<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>    socket<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="2-7-记录日志"><a href="#2-7-记录日志" class="headerlink" title="2.7 记录日志"></a>2.7 记录日志</h3><p>最后，当事务结束时，HTTP服务器会在日志文件中添加一个条目，来描述已经执行的事务。</p><h1 id="3-简单的HTTP服务器"><a href="#3-简单的HTTP服务器" class="headerlink" title="3.简单的HTTP服务器"></a>3.简单的HTTP服务器</h1><p>将以上步骤综合在一起，就可以实现一个简单的HTTP服务器逻辑。这里以请求一个简单的HTML页面<code>abc.html</code>为例。<br>在eclipse中创建一个java项目，代码以及html资源结构如下:</p><p><div align="center/"><img src="https://test-1258680748.cos.ap-shanghai.myqcloud.com/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84HTTP%E6%9C%8D%E5%8A%A1%E5%99%A8/2.PNG" alt="" title="代码结构">    </div></p><p>代码如下：</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HTTPServer</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> port<span class="token punctuation">;</span>        ServerSocket serverSocket<span class="token punctuation">;</span>        <span class="token keyword">try</span><span class="token punctuation">{</span>            port<span class="token operator">=</span>Integer<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>Exception e<span class="token punctuation">)</span><span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"port=8080(默认)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            port<span class="token operator">=</span><span class="token number">8080</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            serverSocket<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ServerSocket</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"服务器正在监听端口："</span><span class="token operator">+</span>serverSocket<span class="token punctuation">.</span><span class="token function">getLocalPort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                Socket socket<span class="token operator">=</span>serverSocket<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//没有时会阻塞 程序停在此处</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"建立了与客户的一个新的TCP连接，该客户的地址为:"</span><span class="token operator">+</span>socket<span class="token punctuation">.</span><span class="token function">getInetAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">":"</span><span class="token operator">+</span>socket<span class="token punctuation">.</span><span class="token function">getPort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token function">service</span><span class="token punctuation">(</span>socket<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// TODO Auto-generated catch block</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// TODO Auto-generated catch block</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">service</span><span class="token punctuation">(</span>Socket socket<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>        InputStream socketIn<span class="token operator">=</span>socket<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//int size=socketIn.available();</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buffer<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        socketIn<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>        String request<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获取HTTP请求的第一行</span>        String firstLineOfRequest<span class="token operator">=</span>request<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>request<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"http请求的第一行:"</span><span class="token operator">+</span>firstLineOfRequest<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//解析HTTP请求的第一行</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> parts<span class="token operator">=</span>firstLineOfRequest<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获取HTTP请求中的URI</span>        String uri<span class="token operator">=</span>parts<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*决定HTTP响应正文的类型*/</span>        String contentType<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>uri<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"html"</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">||</span>uri<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"htm"</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>            contentType<span class="token operator">=</span><span class="token string">"text/html"</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>uri<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"jpg"</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">||</span>uri<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"jpeg"</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>            contentType<span class="token operator">=</span><span class="token string">"image/jpeg"</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>uri<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"gif"</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>            contentType<span class="token operator">=</span><span class="token string">"image/gif"</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            contentType<span class="token operator">=</span><span class="token string">"application/octet-stream"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//字节流类型</span>        <span class="token comment" spellcheck="true">/*创建HTTP响应结果*/</span>        <span class="token comment" spellcheck="true">//HTTP响应的第一行</span>        String responseFirstLine<span class="token operator">=</span><span class="token string">"HTTP/1.1 200 OK\r\n"</span><span class="token punctuation">;</span>        String responseHeader<span class="token operator">=</span><span class="token string">"Content-type:"</span><span class="token operator">+</span>contentType<span class="token operator">+</span><span class="token string">"\r\n\r\n"</span><span class="token punctuation">;</span>        InputStream in<span class="token operator">=</span>HTTPServer<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span><span class="token string">"/server"</span><span class="token operator">+</span>uri<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*发送HTTP响应结果*/</span>        OutputStream socketOut<span class="token operator">=</span>socket<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        socketOut<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>responseFirstLine<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        socketOut<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>responseHeader<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//发送正文</span>        <span class="token keyword">int</span> len<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        buffer<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">128</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>len<span class="token operator">=</span>in<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>            socketOut<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>        socket<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>HTML页面是把nginx的欢迎页拷贝过来的，再配一张favicon.ico的网页标题栏图标。<br>通过chrome浏览器发送请求<code>localhost:8080/abc.html</code>，结果如下：</p><p><div align="center/"><img src="https://test-1258680748.cos.ap-shanghai.myqcloud.com/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84HTTP%E6%9C%8D%E5%8A%A1%E5%99%A8/3.PNG" alt=""></div></p><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h1><ol><li>HTTP协议是基于文本的协议，所以请求行、请求头都可以使用字符串类型的变量来进行处理；</li><li>通过代码学习原理，可以对HTTP协议的原理有更加深入的理解。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-IO</title>
      <link href="/2019/06/24/java-io/"/>
      <url>/2019/06/24/java-io/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Java中的I/O大概可以分成以下几类：</p><ul><li>磁盘操作：File</li><li>字节操作：InputStream和OutputStream</li><li>字符操作：Reader和Writer</li><li>网络操作：Socket</li><li>NIO</li></ul></blockquote><h1 id="1-File"><a href="#1-File" class="headerlink" title="1.File"></a>1.File</h1><p>在操作文件之前，必须创建一个指向文件的链接或实例化一个文件对象，也可以指定一个不存在的文件从而创建它。Java中的<code>File</code>类是文件和目录路径名的抽象形式，它是代表磁盘文件的对象。File类定义了一些与平台无关的方法来操作文件，File类主要用来获取或处理与磁盘文件相关的信息，比如文件名、文件路径、访问权限、修改日期等，还可以浏览子目录层次结构。<code>File</code>类表示处理文件和文件系统的相关信息，也就是说，<strong>File类不具有从文件读取信息和向文件写入信息的功能，它仅描述文件本身的属性</strong>。<br>File类常用的构造方法：</p><table><thead><tr><th style="text-align:left">方法名称</th><th style="text-align:left">方法说明</th></tr></thead><tbody><tr><td style="text-align:left">File(String pathname)</td><td style="text-align:left">通过给定路径名字符串转换成抽象路径名来创建一个File实例</td></tr><tr><td style="text-align:left">File(File parent,String child)</td><td style="text-align:left">根据parent抽象路径名和 child 路径名字符串创建一个File实例</td></tr><tr><td style="text-align:left">File(String parent,String child)</td><td style="text-align:left">根据parent路径名字符串和child路径名字符串创建一个File实例</td></tr></tbody></table><p>注意：在Windows操作系统中，文件路径中的<code>\</code>要替换为<code>\\</code>。使用任意一个构造方法都可以创建一个File对象，然后调用其提供的方法对文件进行操作，以下是File类的常用方法以及说明：</p><table><thead><tr><th style="text-align:center">方法名称</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">boolean canRead()</td><td style="text-align:center">测试应用程序是否能从指定的文件中进行读取</td></tr><tr><td style="text-align:center">boolean canWrite()</td><td style="text-align:center">测试应用程序是否能从指定的文件中进行写入</td></tr><tr><td style="text-align:center">boolean exists()</td><td style="text-align:center">测试当前File对象对应的文件是否存在</td></tr><tr><td style="text-align:center">boolean isDirectory()</td><td style="text-align:center">测试当前File对象表示的文件是否为一个目录文件</td></tr><tr><td style="text-align:center">boolean isFile()</td><td style="text-align:center">测试当前File对象表示的文件是否为一个“普通”文件</td></tr><tr><td style="text-align:center">String[] list()</td><td style="text-align:center">返回当前File对象指定的路径文件列表</td></tr><tr><td style="text-align:center">File() listFiles()</td><td style="text-align:center">返回当前File对象对应的目录中的所有文件对象</td></tr><tr><td style="text-align:center">String getName()</td><td style="text-align:center">返回表示当前对象的对应文件的文件名</td></tr><tr><td style="text-align:center">boolean createNewFile()</td><td style="text-align:center">当前File对象对应文件不存在时，创建一个新的以当前File对象命名的文件</td></tr><tr><td style="text-align:center">boolean mkdir()</td><td style="text-align:center">创建一个目录，它的路径名由当前File对象指定</td></tr><tr><td style="text-align:center">boolean delete()</td><td style="text-align:center">删除当前对象指定的文件</td></tr></tbody></table><p>注意：在有关权限的操作中，比如<code>canRead()</code>、<code>canWrite()</code>等，在有些平台上Java虚拟机以特权方式启动，所以可以修改那些只读文件，所以对于有些只读文件(比如windows中的hosts文件)也有可能返回true。<br>递归地列出一个目录下所有文件：</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">listAllFiles</span><span class="token punctuation">(</span>File dir<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>dir <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token operator">!</span>dir<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>dir<span class="token punctuation">.</span><span class="token function">isFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dir<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>File file <span class="token operator">:</span> dir<span class="token punctuation">.</span><span class="token function">listFiles</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">listAllFiles</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h1 id="2-字节输入流"><a href="#2-字节输入流" class="headerlink" title="2.字节输入流"></a>2.字节输入流</h1><p>字节输入流有关的类的继承关系如下：</p><p><div align="center/"><img src="https://test-1258680748.cos.ap-shanghai.myqcloud.com/Java%20I/1.PNG" alt="" title="字节输入流"><br>从图中可以看出：<code>InputStream</code>是抽象类，其中定义了输入流的方法模版，比如：<code>read()</code>、<code>skip()</code>、<code>mark()</code>、<code>close()</code>等。但是抽象类并不能实例化，在使用时需要根据实际的输入流类型选择合适的输入流。如果要从文件中输入数据，则要使用<code>FileInputStream</code>；如果从内存中的数组中读取数据，则要使用<code>ByteArrayInputStream</code>。<br>输入流中最常用的方法就是<code>read()</code>，不同形式的<code>read()</code>方法有不同的行为：</div></p><table><thead><tr><th style="text-align:center">方法名称</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">int read()</td><td style="text-align:center">从输入流中读取单个字节，返回所读取的字节数据</td></tr><tr><td style="text-align:center">int read(byte[] b)</td><td style="text-align:center">从输入流中最多读取b.length个字节的数据，并将其存储在字节数组b中，返回实际读取的字节数</td></tr><tr><td style="text-align:center">int read(byte[] b, int off, int len)</td><td style="text-align:center">从输入流中最多读取len个字节的数据，并将其存储在字节数组b中，放入数组b中时，从off位置开始，返回实际读取的字节数</td></tr></tbody></table><p>注意：<code>FileInputStream</code>和<code>ByteArrayInputStream</code>中<code>read()</code>方法的实现是不同的，因为它们要读取的数据源是不同的：FileInputStream中的read()方法其实是被定义为<code>native</code>的本地方法，而ByteArrayInputStream中的read()方法则是通过数组拷贝<code>System.arrayCopy()</code>实现。<br><strong>实现文件复制</strong></p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">copyFile</span><span class="token punctuation">(</span>String src<span class="token punctuation">,</span> String dist<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    FileInputStream in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">;</span>    FileOutputStream out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span>dist<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">20</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> cnt<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// read() 最多读取 buffer.length 个字节</span>    <span class="token comment" spellcheck="true">// 返回的是实际读取的个数</span>    <span class="token comment" spellcheck="true">// 返回 -1 的时候表示读到 eof，即文件尾</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>cnt <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> buffer<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        out<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    in<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    out<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>装饰器模式</strong>：<br>Java I/O使用了装饰者模式，以InputStream为例:</p><ul><li><code>InputStream</code>是抽象组件；</li><li><code>FileInputStream</code>是InputStream的子类，是具体组件，提供了字节流的输入操作；</li><li><p><code>FilterInputStream</code>属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能。<br>比如：<code>BufferedInputStream</code>是具有缓冲功能的输入流，如果想使<code>FileInputStream</code>具有缓冲功能，就可以用BufferedInputStream装饰FileInputStream：</p><pre class=" language-java"><code class="language-java">  FileInputStream fi <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>filePath<span class="token punctuation">)</span><span class="token punctuation">;</span>  BufferedInputStream bi <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedInputStream</span><span class="token punctuation">(</span>fi<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在<code>BufferedInputStream</code>中，有关缓存的代码如下：</p><pre class=" language-java"><code class="language-java">  <span class="token keyword">public</span>    <span class="token keyword">class</span> <span class="token class-name">BufferedInputStream</span> <span class="token keyword">extends</span>    <span class="token class-name">FilterInputStream</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//默认缓冲区大小为8MB</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> DEFAULT_BUFFER_SIZE <span class="token operator">=</span> <span class="token number">8192</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//缓存数据使用的数组</span>  <span class="token keyword">protected</span> <span class="token keyword">volatile</span> <span class="token keyword">byte</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/**  * The index one greater than the index of the last *valid byte in the buffer.  */</span>  <span class="token comment" spellcheck="true">//比有效字节大1的索引</span>  <span class="token keyword">protected</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//下次将要读取的字节索引</span>  <span class="token keyword">protected</span> <span class="token keyword">int</span> pos<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//默认创建8MB大小的缓存数组</span>  <span class="token keyword">public</span> <span class="token function">BufferedInputStream</span><span class="token punctuation">(</span>InputStream in<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">(</span>in<span class="token punctuation">,</span> DEFAULT_BUFFER_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//super(in)是调用其父类FilterInputStream中的构造方法，因为其父类中有一个InputStream变量，所以该方法就是将传进来的InputStream对象付给InputStream变量</span>  <span class="token keyword">public</span> <span class="token function">BufferedInputStream</span><span class="token punctuation">(</span>InputStream in<span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">super</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Buffer size &lt;= 0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      buf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">int</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">>=</span> count<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token function">fill</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">>=</span> count<span class="token punctuation">)</span>              <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">//直接从缓存数组中取一个数据</span>      <span class="token keyword">return</span> <span class="token function">getBufIfOpen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span>pos<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token number">0xff</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">fill</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>      <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buffer <span class="token operator">=</span> <span class="token function">getBufIfOpen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>markpos <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>          pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/* no mark: throw away the buffer */</span>      <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">>=</span> buffer<span class="token punctuation">.</span>length<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">/* no room left in buffer */</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>markpos <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">/* can throw away early part of the buffer */</span>              <span class="token keyword">int</span> sz <span class="token operator">=</span> pos <span class="token operator">-</span> markpos<span class="token punctuation">;</span>              System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> markpos<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> sz<span class="token punctuation">)</span><span class="token punctuation">;</span>              pos <span class="token operator">=</span> sz<span class="token punctuation">;</span>              markpos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>buffer<span class="token punctuation">.</span>length <span class="token operator">>=</span> marklimit<span class="token punctuation">)</span> <span class="token punctuation">{</span>              markpos <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* buffer got too big, invalidate mark */</span>              pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* drop buffer contents */</span>          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>buffer<span class="token punctuation">.</span>length <span class="token operator">>=</span> MAX_BUFFER_SIZE<span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">OutOfMemoryError</span><span class="token punctuation">(</span><span class="token string">"Required array size too large"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">/* grow buffer */</span>              <span class="token keyword">int</span> nsz <span class="token operator">=</span> <span class="token punctuation">(</span>pos <span class="token operator">&lt;=</span> MAX_BUFFER_SIZE <span class="token operator">-</span> pos<span class="token punctuation">)</span> <span class="token operator">?</span>                      pos <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">:</span> MAX_BUFFER_SIZE<span class="token punctuation">;</span>              <span class="token keyword">if</span> <span class="token punctuation">(</span>nsz <span class="token operator">></span> marklimit<span class="token punctuation">)</span>                  nsz <span class="token operator">=</span> marklimit<span class="token punctuation">;</span>              <span class="token keyword">byte</span> nbuf<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span>nsz<span class="token punctuation">]</span><span class="token punctuation">;</span>              System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nbuf<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> pos<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>bufUpdater<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> nbuf<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  <span class="token comment" spellcheck="true">// Can't replace buf if there was an async close.</span>                  <span class="token comment" spellcheck="true">// Note: This would need to be changed if fill()</span>                  <span class="token comment" spellcheck="true">// is ever made accessible to multiple threads.</span>                  <span class="token comment" spellcheck="true">// But for now, the only way CAS can fail is via close.</span>                  <span class="token comment" spellcheck="true">// assert buf == null;</span>                  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IOException</span><span class="token punctuation">(</span><span class="token string">"Stream closed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token punctuation">}</span>              buffer <span class="token operator">=</span> nbuf<span class="token punctuation">;</span>          <span class="token punctuation">}</span>      count <span class="token operator">=</span> pos<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//getInIfOpen()就是返回构造函数中的输入流对象</span>      <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token function">getInIfOpen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> pos<span class="token punctuation">,</span> buffer<span class="token punctuation">.</span>length <span class="token operator">-</span> pos<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>          count <span class="token operator">=</span> n <span class="token operator">+</span> pos<span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre><p>从<code>BufferedInputStream</code>中<code>read()</code>方法的实现中可以看出：如果可以从缓存数组中读取数据，则在缓存数组中读取一个字节的数据；如果缓存数组中的数据都已经被读取过，则先调用<code>fill()</code>方法进而调用实际输入流对象的<code>read()</code>方法读取数据，在从缓存中返回需要的数据。也就是说，<code>BufferedInputStream</code>中的<code>read()</code>方法装饰了<code>FileInputStream</code>中的<code>read()</code>方法，使其具有了缓存功能。</p><h1 id="3-字节输出流"><a href="#3-字节输出流" class="headerlink" title="3.字节输出流"></a>3.字节输出流</h1><p>字节输入流有关的类的继承关系如下：<br><div align="center/"><img src="https://test-1258680748.cos.ap-shanghai.myqcloud.com/Java%20I/2.PNG" alt="" title="字节输出流"><br>类似于<code>InputStream</code>，<code>OutputStream</code>也是抽象类，定义了输出流的方法模板，比如：<code>write()</code>、<code>flush()</code>、<code>close()</code>。<br><code>OutputStream</code>常用方法如下：</div></p></li></ul><table><thead><tr><th style="text-align:center">方法名称</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">void write(int b)</td><td style="text-align:center">向输出流写入一个字节，写入b的低8位，高24位被忽略</td></tr><tr><td style="text-align:center">void write(byte[] b))</td><td style="text-align:center">将参数b指定的字节数组中的所有字节写到输出流中</td></tr><tr><td style="text-align:center">void write(byte[] b, int off, int len)</td><td style="text-align:center">将参数b指定的字节数组中的若干字节写到输出流中。off制定字节数组的起始下标，len表示写入的字节数</td></tr><tr><td style="text-align:center">void flush()</td><td style="text-align:center">为了提高效率，在向输出流中写入数据时，数据一般先保存在内存缓冲区，只有当缓冲区的数据到达一定数量时，缓冲区中的数据才会被写入输出流中。使用 flush() 方法则可以强制将缓冲区中的数据写入输出流，并清空缓冲区</td></tr><tr><td style="text-align:center">void close()</td><td style="text-align:center">关闭输出流。写操作完成后，应该关闭输出流。系统将会释放与这个输出流相关的资源</td></tr></tbody></table><h1 id="4-字符输入流"><a href="#4-字符输入流" class="headerlink" title="4.字符输入流"></a>4.字符输入流</h1><p>字符输入流有关的类的继承关系如下：</p><p><div align="center/"><img src="https://test-1258680748.cos.ap-shanghai.myqcloud.com/Java%20I/3.PNG" alt="" title="字符输入流"><br>抽象类<code>Reader</code>中定义了一个Object变量：<code>protected Object lock;</code>：为了保护输入流的临界区，供<code>sychronized</code>使用；此外还有模版方法<code>read()</code>以及它的几种重载形式，<code>skip()</code>、<code>ready()</code>、<code>mark()</code>、<code>reset()</code>和<code>close()</code>等方法。<br><code>Reader</code>类中的3种重载的<code>read()</code>方法：</div></p><table><thead><tr><th style="text-align:center">方法名称</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">int read()</td><td style="text-align:center">从输入流中读取一个字符，将其转换为0~65535的整数。如果返回-1，则表示已经到了输入流的末尾</td></tr><tr><td style="text-align:center">int read(char[] chuf)</td><td style="text-align:center">从输入流中读取若干个字符，并把它们保存到参数cbuf指定的字符数组中。返回读取的字符数。如果返回-1，表示已经到了输入流的末尾</td></tr><tr><td style="text-align:center">int read(char[] cbuf, int off, int len)</td><td style="text-align:center">从输入流中读取若干个字符，并把它们保存到参数cbuf指定的字符数组中。off指定在字符数组中开始保存数据的起始下标，len指定读取的字符数。方法返回实际读取的字符数，返回-1表示已经到了输入流的末尾</td></tr></tbody></table><p><code>CharArrayReader</code>中的<code>read()</code>方法是用<code>System.arrayCopy()</code>方法实现；<code>StringReader</code>中的<code>read()</code>方法是用<code>getChars()</code>实现。</p><h1 id="5-字符输出流"><a href="#5-字符输出流" class="headerlink" title="5.字符输出流"></a>5.字符输出流</h1><p>字符输出流有关的类的继承关系如下：</p><p><div align="center/"><img src="https://test-1258680748.cos.ap-shanghai.myqcloud.com/Java%20I/4.PNG" alt="" title="字符输出流"><br><code>Writer</code>类中的<code>write()</code>方法和<code>append()</code>方法：</div></p><table><thead><tr><th style="text-align:center">方法名称</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">void write()</td><td style="text-align:center">向输出流中写入一个字符</td></tr><tr><td style="text-align:center">void write(char[] chuf)</td><td style="text-align:center">把参数cbuf指定的字符数组中的所有字符写到输出流中</td></tr><tr><td style="text-align:center">void write(char[] cbuf, int off, int len)</td><td style="text-align:center">把参数cbuf指定的字符数组中的从off开始的len个字符写入到输出流中</td></tr><tr><td style="text-align:center">void write(String str)</td><td style="text-align:center">向输出流中写入一个字符串</td></tr><tr><td style="text-align:center">void write(String str, int off, int len)</td><td style="text-align:center">向输出流中写入一个字符串的部分字符。off指定字符串的起始位置，len表示字符个数</td></tr><tr><td style="text-align:center">Writer append(char c)</td><td style="text-align:center">将参数c指定的字符添加到输出流中</td></tr><tr><td style="text-align:center">Writer append(CharSequence esq)</td><td style="text-align:center">将参数esq指定的字符序列添加到输出流中</td></tr><tr><td style="text-align:center">Writer append(CharSequence esq, int start, int end)</td><td style="text-align:center">将参数esq指定的字符序列的子序列添加到输出流中。start指定子序列的第一个字符的索引，end指定子序列中最后一个字符的下一个位置。子序列的内容是[start, end)</td></tr></tbody></table><h1 id="6-常用I-O流"><a href="#6-常用I-O流" class="headerlink" title="6.常用I/O流"></a>6.常用I/O流</h1><h3 id="6-1-转换流"><a href="#6-1-转换流" class="headerlink" title="6.1 转换流"></a>6.1 转换流</h3><p>不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符。但是在程序中操作的通常是字符形式的数据，所以，在从输入流中读取数据时，需要将读取到的字节流转换成字符类型，在向输出流输出数据时需要将字符数据编码成字节数据。</p><ul><li>InputStreamReader：<br><code>InputStreamReader</code>用于<strong>解码输入流</strong>：<br><div align="center/"><img src="https://test-1258680748.cos.ap-shanghai.myqcloud.com/Java%20I/5.PNG" alt="" title="解码流"><br><code>输入流</code>中的编码方式由具体的流的编码方式决定，java<code>内存</code>中以<code>UTF-16</code>双字节编码字符。</div></li><li>OutputStreamWriter：<br><code>OutputStreamWriter</code>用于<strong>编码输出流</strong>：<br><div align="center/"><img src="https://test-1258680748.cos.ap-shanghai.myqcloud.com/Java%20I/6.PNG" alt="" title="编码流"><br><code>内存</code>中的字符以UTF-16编码，向输出流输出时需要先重新编码为<code>指定编码</code>之后再输出。    </div></li></ul><h3 id="6-2-字节文件流"><a href="#6-2-字节文件流" class="headerlink" title="6.2 字节文件流"></a>6.2 字节文件流</h3><p>字符文件输入流和字符文件输出流：</p><ul><li><code>FileReader</code>：创建该类的对象时，默认的字符编码及字节缓冲区大小都是系统默认的。构造方法：</li></ul><table><thead><tr><th style="text-align:center">方法名称</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">FileReader(File file)</td><td style="text-align:center">在给定要读取数据的文件的情况下创建一个FileReader对象</td></tr><tr><td style="text-align:center">FileReader(String fileName)</td><td style="text-align:center">在给定从中读取数据的文件名的情况下创建一个FileReader对象，fileName表示文件名称</td></tr></tbody></table><p><code>FileReader</code>继承自<code>InputStreamReader</code>，在<code>FileReader</code>源代码中只有3个重载的构造方法，可见使用它时都是调用它的父类中的方法。</p><ul><li><code>FileWriter</code>：创建 FileWriter 对象时，默认字符编码和默认字节缓冲区大小都是由系统默认的。构造方法：</li></ul><table><thead><tr><th style="text-align:center">方法名称</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">FileWriter(File file)</td><td style="text-align:center">在给定要读取数据的文件的情况下创建一个FileWriter对象</td></tr><tr><td style="text-align:center">FileWriter(File file, boolean append)</td><td style="text-align:center">在指定 File 对象的情况下构造一个 FileWriter 对象，如果 append 的值为 true，则将字节写入文件末尾，而不是写入文件开始处</td></tr><tr><td style="text-align:center">FileWriter(String fileName)</td><td style="text-align:center">在指定文件名的情况下构造一个 FileWriter 对象。其中，fileName 表示要写入字符的文件名，表示的是完整路径</td></tr><tr><td style="text-align:center">FileWriter(String fileName,boolean append)</td><td style="text-align:center">在指定文件名以及要写入文件的位置的情况下构造 FileWriter 对象。其中，append 是一个 boolean 值，如果为 true，则将数据写入文件末尾，而不是文件开始处</td></tr></tbody></table><p>FileWriter类的创建不依赖于文件存在与否，如果关联文件不存在，则会自动生成一个新的文件。</p><h3 id="6-3-字符缓冲流"><a href="#6-3-字符缓冲流" class="headerlink" title="6.3 字符缓冲流"></a>6.3 字符缓冲流</h3><ul><li><code>BufferedReader</code>：该类主要用于辅助其他字符输入流，它带有缓冲区，可以先将一批数据读到内存缓冲区。接下来的读操作就可以直接从缓冲区中获取数据，而不需要每次都从数据源读取数据并进行字符编码转换，这样就可以提高数据的读取效率。<br>除了为字符流提供缓冲区以外，<code>BufferedReader</code>还提供了<code>readLine()</code>方法，返回包含该行内容的字符串。</li><li><code>BufferedWriter</code>：该类主要用于辅助其他字符输出流，它也是带有缓冲区的，目的是提高数据的写效率。<br>该类除了可以给字符输出流提供缓冲区之外，还提供了一个新的方法：<code>newLine()</code>，该方法用于写入一个行分隔符。行分隔符字符串由系统属性 line.separator 定义，并且不一定是单个新行（\n）符。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> I/O </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的Comparable和Comparator</title>
      <link href="/2019/06/16/java-zhong-de-comparable-he-comparator/"/>
      <url>/2019/06/16/java-zhong-de-comparable-he-comparator/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Comparable接口"><a href="#1-Comparable接口" class="headerlink" title="1.Comparable接口"></a>1.Comparable接口</h1><p>Comparable接口是用于排序的接口。它的定义如下：</p><pre class=" language-java"><code class="language-java">    <span class="token operator">/</span><span class="token operator">*</span><span class="token operator">*</span>     <span class="token operator">*</span> This <span class="token keyword">interface</span> <span class="token class-name">imposes</span> a total ordering on the objects of each <span class="token keyword">class</span> <span class="token class-name">that</span>     <span class="token operator">*</span> <span class="token keyword">implements</span> <span class="token class-name">it<span class="token punctuation">.</span></span>  This ordering is referred to as the <span class="token keyword">class</span>'s <span class="token operator">&lt;</span>i<span class="token operator">></span>natural     <span class="token operator">*</span> ordering<span class="token operator">&lt;</span><span class="token operator">/</span>i<span class="token operator">></span><span class="token punctuation">,</span> and the <span class="token keyword">class</span>'s <span class="token operator">&lt;</span>tt<span class="token operator">></span>compareTo<span class="token operator">&lt;</span><span class="token operator">/</span>tt<span class="token operator">></span> method is referred to as     <span class="token operator">*</span> its <span class="token operator">&lt;</span>i<span class="token operator">></span>natural comparison method<span class="token operator">&lt;</span><span class="token operator">/</span>i<span class="token operator">></span><span class="token punctuation">.</span>&lt;p<span class="token operator">></span>     <span class="token operator">*</span>     <span class="token operator">*</span> <span class="token function">Lists</span> <span class="token punctuation">(</span>and arrays<span class="token punctuation">)</span> of objects that implement <span class="token keyword">this</span> <span class="token keyword">interface</span> <span class="token class-name">can</span> be sorted     <span class="token operator">*</span> automatically by <span class="token punctuation">{</span><span class="token annotation punctuation">@link</span> Collections#<span class="token function">sort</span><span class="token punctuation">(</span>List<span class="token punctuation">)</span> Collections<span class="token punctuation">.</span>sort<span class="token punctuation">}</span> <span class="token punctuation">(</span>and     <span class="token operator">*</span> <span class="token punctuation">{</span><span class="token annotation punctuation">@link</span> Arrays#<span class="token function">sort</span><span class="token punctuation">(</span>Object<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> Arrays<span class="token punctuation">.</span>sort<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span>  Objects that implement <span class="token keyword">this</span>     <span class="token operator">*</span> <span class="token keyword">interface</span> <span class="token class-name">can</span> be used as keys in a <span class="token punctuation">{</span><span class="token annotation punctuation">@linkplain</span> SortedMap sorted map<span class="token punctuation">}</span> or as     <span class="token operator">*</span> elements in a <span class="token punctuation">{</span><span class="token annotation punctuation">@linkplain</span> SortedSet sorted set<span class="token punctuation">}</span><span class="token punctuation">,</span> without the need to     <span class="token operator">*</span> specify a <span class="token punctuation">{</span><span class="token annotation punctuation">@linkplain</span> Comparator comparator<span class="token punctuation">}</span><span class="token punctuation">.</span>&lt;p<span class="token operator">></span>     <span class="token operator">*</span> <span class="token operator">/</span>    <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token operator">/</span><span class="token operator">*</span><span class="token operator">*</span>        <span class="token operator">*</span>Compares <span class="token keyword">this</span> object with the specified object <span class="token keyword">for</span> order<span class="token punctuation">.</span>  Returns a         <span class="token operator">*</span> negative integer<span class="token punctuation">,</span> zero<span class="token punctuation">,</span> or a positive integer as <span class="token keyword">this</span> object is less         <span class="token operator">*</span> than<span class="token punctuation">,</span> equal to<span class="token punctuation">,</span> or greater than the specified object<span class="token punctuation">.</span>         <span class="token operator">*</span> <span class="token operator">/</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span>T o<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    </code></pre><p>注释中说到：这个接口对实现了该接口的类施行了一个总体的顺序，这种排序被称为类的自然排序，类的<code>compareTo</code>方法被称为自然排序方法。（也就是说这个接口规定了实现该接口的类的排序规则）。然后是，实现这个接口的类的对象的列表和数组可以被<code>Collections.sort()</code>和<code>Arrays.sort()</code>两个方法自动排序；实现该接口的类的对象可以被用作<code>SortedMap</code>的key以及<code>SortedSet</code>的元素，而不需要定义一个<code>Comparator</code>。<br>&ensp;<code>compareTo(T o)</code>方法的注释中：将该对象与另一对象比较，返回一个<strong>负整数、零或正整数</strong>被看作该对象<strong>小于、等于或大于另一对象</strong>。看如下这段代码：定义了一个可以排序的Person类</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span>    <span class="token punctuation">{</span>        String name<span class="token punctuation">;</span>        <span class="token keyword">int</span> age<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">Person</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>        <span class="token punctuation">}</span>　　        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>        <span class="token keyword">return</span> age<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span>Person p<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token operator">-</span>p<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>因为Person类实现了<code>Comparable</code>接口，重写了<code>compareTo</code>方法，所以对于一个Person数组，就可以用<code>Arrays.sort()</code>方法对该数组进行排序。在<code>Arrays.sort()</code>方法进行排序的过程中，会<strong>把需要排序的对象类型转换为Comparable，然后再调用该对象的compareTo方法。</strong></p><h1 id="2-Comparator接口"><a href="#2-Comparator接口" class="headerlink" title="2.Comparator接口"></a>2.Comparator接口</h1><p>Comparator接口也是用来排序的接口，它的定义如下：</p><pre class=" language-java"><code class="language-java">    <span class="token operator">/</span><span class="token operator">*</span><span class="token operator">*</span>     <span class="token operator">*</span> A comparison function<span class="token punctuation">,</span> which imposes a <span class="token operator">&lt;</span>i<span class="token operator">></span>total ordering<span class="token operator">&lt;</span><span class="token operator">/</span>i<span class="token operator">></span> on some     <span class="token operator">*</span> collection of objects<span class="token punctuation">.</span>  Comparators can be passed to a sort <span class="token function">method</span> <span class="token punctuation">(</span>such     <span class="token operator">*</span> as <span class="token punctuation">{</span><span class="token annotation punctuation">@link</span> Collections#<span class="token function">sort</span><span class="token punctuation">(</span>List<span class="token punctuation">,</span>Comparator<span class="token punctuation">)</span> Collections<span class="token punctuation">.</span>sort<span class="token punctuation">}</span> or <span class="token punctuation">{</span><span class="token annotation punctuation">@link</span>     <span class="token operator">*</span> Arrays#<span class="token function">sort</span><span class="token punctuation">(</span>Object<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>Comparator<span class="token punctuation">)</span> Arrays<span class="token punctuation">.</span>sort<span class="token punctuation">}</span><span class="token punctuation">)</span> to allow precise control     <span class="token operator">*</span> over the sort order<span class="token punctuation">.</span>  Comparators can also be used to control the order of     <span class="token operator">*</span> certain data <span class="token function">structures</span> <span class="token punctuation">(</span>such as <span class="token punctuation">{</span><span class="token annotation punctuation">@link</span> SortedSet sorted sets<span class="token punctuation">}</span> or <span class="token punctuation">{</span><span class="token annotation punctuation">@link</span>     <span class="token operator">*</span> SortedMap sorted maps<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span> or to provide an ordering <span class="token keyword">for</span> collections of     <span class="token operator">*</span> objects that don't have a <span class="token punctuation">{</span><span class="token annotation punctuation">@link</span> Comparable natural ordering<span class="token punctuation">}</span><span class="token punctuation">.</span>&lt;p<span class="token operator">></span>     <span class="token operator">*</span>     <span class="token operator">*</span> The ordering imposed by a comparator <span class="token operator">&lt;</span>tt<span class="token operator">></span>c<span class="token operator">&lt;</span><span class="token operator">/</span>tt<span class="token operator">></span> on a set of elements     <span class="token operator">*</span> <span class="token operator">&lt;</span>tt<span class="token operator">></span>S<span class="token operator">&lt;</span><span class="token operator">/</span>tt<span class="token operator">></span> is said to be <span class="token operator">&lt;</span>i<span class="token operator">></span>consistent with equals<span class="token operator">&lt;</span><span class="token operator">/</span>i<span class="token operator">></span> <span class="token keyword">if</span> and only <span class="token keyword">if</span>     <span class="token operator">*</span> <span class="token operator">&lt;</span>tt<span class="token operator">></span>c<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>e1<span class="token punctuation">,</span> e2<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token operator">&lt;</span><span class="token operator">/</span>tt<span class="token operator">></span> has the same <span class="token keyword">boolean</span> value as     <span class="token operator">*</span> <span class="token operator">&lt;</span>tt<span class="token operator">></span>e1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>e2<span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token operator">/</span>tt<span class="token operator">></span> <span class="token keyword">for</span> every <span class="token operator">&lt;</span>tt<span class="token operator">></span>e1<span class="token operator">&lt;</span><span class="token operator">/</span>tt<span class="token operator">></span> and <span class="token operator">&lt;</span>tt<span class="token operator">></span>e2<span class="token operator">&lt;</span><span class="token operator">/</span>tt<span class="token operator">></span> in     <span class="token operator">*</span> <span class="token operator">&lt;</span>tt<span class="token operator">></span>S<span class="token operator">&lt;</span><span class="token operator">/</span>tt<span class="token operator">></span><span class="token punctuation">.</span>&lt;p<span class="token operator">></span>     <span class="token operator">*</span> <span class="token operator">/</span>     <span class="token annotation punctuation">@FunctionalInterface</span>    <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token operator">/</span><span class="token operator">*</span><span class="token operator">*</span>         <span class="token operator">*</span> Compares its two arguments <span class="token keyword">for</span> order<span class="token punctuation">.</span>  Returns a negative integer<span class="token punctuation">,</span>         <span class="token operator">*</span> zero<span class="token punctuation">,</span> or a positive integer as the first argument is less than<span class="token punctuation">,</span> equal         <span class="token operator">*</span> to<span class="token punctuation">,</span> or greater than the second<span class="token punctuation">.</span>&lt;p<span class="token operator">></span>         <span class="token operator">*</span> <span class="token operator">/</span>         <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span>T o1<span class="token punctuation">,</span> T o2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span></code></pre><p>从注释中可以看出该接口也是用于对象集合进行排序的，可以在调用<code>Collections.sort(List,Comparator)</code>和<code>Arrays.sort(Object[],Comparator)</code>的时候，指明其中元素的排序规则。在<code>int compare(T o1, T o2)</code>方法的注释中，也说明了该函数用于比较两个参数，返回负整数、零和正整数分别代表第一个参数小于、等于和大于第二个参数。<br>如下代码是Comparator接口的用法:</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">class</span> <span class="token class-name">PersonComparator</span> <span class="token keyword">implements</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span>Person<span class="token operator">></span>    <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span>Person o1<span class="token punctuation">,</span> Person o2<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">return</span> o1<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>o2<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span>    <span class="token punctuation">{</span>        String name<span class="token punctuation">;</span>        <span class="token keyword">int</span> age<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">Person</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">return</span> name<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">return</span> age<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            Person<span class="token punctuation">[</span><span class="token punctuation">]</span> people<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"xujian"</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"xiewei"</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"排序前"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Person person <span class="token operator">:</span> people<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">":"</span><span class="token operator">+</span>person<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>people<span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">PersonComparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"\n排序后"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Person person <span class="token operator">:</span> people<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">":"</span><span class="token operator">+</span>person<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>也就是说对Person的排序规则是：年龄小的Person小于年龄大的Person。<br>同理，在调用Arrays.sort()的过程中也会使用传入的Comparator对象的compare()方法进行大小的比较。</p><h1 id="3-Comparable和Comparator的对比"><a href="#3-Comparable和Comparator的对比" class="headerlink" title="3.Comparable和Comparator的对比"></a>3.Comparable和Comparator的对比</h1><p>&ensp;&ensp;&ensp;&ensp;Comparable是排序接口，如果一个类实现了Comparable接口，就意味着该类的对象是支持排序的；而Comparator是比较器的接口，如果需要控制某个类的次序，可以建立一个关于该类的实现Comparator接口的比较器进行排序。<br>&ensp;&ensp;&ensp;&ensp;Comparable相当于“内部比较器”，而Comparator可以看作“外部比较器”。<br>&ensp;&ensp;&ensp;&ensp;两个接口的使用各有优劣：Comparable简单，实现该接口的类的对象就可以进行排序，但是如果之后需要修改排序规则，就需要修改该类的源代码；而Comparator的用法是在需要对类A的对象进行排序时传入一个该接口的实现类，在实现类中定义比较的逻辑，这样做就不需要对类A的源代码进行修改，相对于Comparable接口更具有灵活性。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> JDK源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java容器-LinkedList</title>
      <link href="/2019/06/04/java-rong-qi-linkedlist/"/>
      <url>/2019/06/04/java-rong-qi-linkedlist/</url>
      
        <content type="html"><![CDATA[<blockquote><p>LinkedList平时还是比较常用的，但是一直对它提供的方法停留在会用的阶段，今天终于忍不住打开了它的实现来一探究竟。</p></blockquote><h1 id="1-LinkedList的声明"><a href="#1-LinkedList的声明" class="headerlink" title="1.LinkedList的声明"></a>1.LinkedList的声明</h1><p>LinkedList的声明如下:<br>&ensp;<code>public class LinkedList&lt;E&gt;    extends AbstractSequentialList&lt;E&gt;    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</code><br>从它的声明可以看出：LinkedList继承自AbstractSequentialList,实现了List和<br>Deque等接口。其中Deque是<code>double ended queue</code>的意思，也就是实现这个接口的集合可以提供从其头部和尾部插入、删除其中元素。</p><h1 id="2-LinkedList的基础-Node"><a href="#2-LinkedList的基础-Node" class="headerlink" title="2.LinkedList的基础-Node"></a>2.LinkedList的基础-Node</h1><p>源码的前几行便出现了被定义为Node类型的first和last变量，Node是LinkedList的静态内部类，它的定义如下：</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>        E item<span class="token punctuation">;</span>        Node<span class="token operator">&lt;</span>E<span class="token operator">></span> next<span class="token punctuation">;</span>        Node<span class="token operator">&lt;</span>E<span class="token operator">></span> prev<span class="token punctuation">;</span>        <span class="token function">Node</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> prev<span class="token punctuation">,</span> E element<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>item <span class="token operator">=</span> element<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>prev <span class="token operator">=</span> prev<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>从Node的定义可以看出：它有一个E类型的item，剩下两个变量就是指向另外两个Node的引用变量，可以猜出LinkedList内部其实维护了一个双向链表。</p><h1 id="3-LinkedList的成员变量"><a href="#3-LinkedList的成员变量" class="headerlink" title="3.LinkedList的成员变量"></a>3.LinkedList的成员变量</h1><p>LinkedList中定义了如下三个变量：</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">transient</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * Pointer to first node.     * Invariant: (first == null &amp;&amp; last == null) ||     *            (first.prev == null &amp;&amp; first.item != null)     */</span>    <span class="token keyword">transient</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> first<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * Pointer to last node.     * Invariant: (first == null &amp;&amp; last == null) ||     *            (last.next == null &amp;&amp; last.item != null)     */</span>    <span class="token keyword">transient</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> last<span class="token punctuation">;</span></code></pre><p>并且注释告诉了我们两个真理。如果对链表不陌生的话，这应该是比较好理解的。</p><h1 id="4-向LinkedList中添加元素"><a href="#4-向LinkedList中添加元素" class="headerlink" title="4.向LinkedList中添加元素"></a>4.向LinkedList中添加元素</h1><p>LinkedList给出了两个构造函数，其中一个需要传入一个Collection的实现类的对象，另一个则不需要参数。如果使用<code>List&lt;String&gt; l = new LinkedList&lt;&gt;();</code>创建一个LinkedList对象，那么就会调用空的构造函数：</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * Constructs an empty list.     */</span>    <span class="token keyword">public</span> <span class="token function">LinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span></code></pre><p>前面在定义变量时没有给变量赋值，构造函数中也没有给变量赋值，那刚刚创建的LinkedList对象中的first和last只能为null。<br>当调用<code>add()</code>方法向其中加元素时，该方法会对集合进行如下操作：</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     *Appends the specified element to the end of this list.     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">linkLast</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Links e as last element.     */</span>    <span class="token keyword">void</span> <span class="token function">linkLast</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> l <span class="token operator">=</span> last<span class="token punctuation">;</span>        <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> e<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        last <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> null<span class="token punctuation">)</span>            first <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        <span class="token keyword">else</span>            l<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        size<span class="token operator">++</span><span class="token punctuation">;</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>从注释中可以看出add会向双向链表的尾部添加一个节点，从代码中也可以看出的确是这样的：1.记录下最后一个节点；2.新建一个节点，设置它的值以及两个指针域；3.使last指向最后一个节点；4.由于是第一次加入，所以会进入if后面的语句：使first也指向这个新建的节点，如果链表中已经有节点了，那就要设置前一个节点的next域指向新建的节点；5.最后，容器的size加1，modCount也加1。</p>]]></content>
      
      
      <categories>
          
          <category> Java集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> JDK源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机_垃圾收集</title>
      <link href="/2019/06/03/java-xu-ni-ji-la-ji-shou-ji/"/>
      <url>/2019/06/03/java-xu-ni-ji-la-ji-shou-ji/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Java平台最重要的特点之一就是提供了自动垃圾回收的功能，相比于c/c++手动释放没有用的内存，自动垃圾回收可以使Java代码更加简洁并且可以使编程者更加注重于代码的业务功能。到目前为止，内存的动态分配与自动垃圾回收技术已经相当成熟，但是当需要排查各种内存溢出、内存泄露问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，就需要对这些“自动化”的技术实施必要的监控和调节。</p></blockquote><h1 id="1-垃圾回收的主要对象"><a href="#1-垃圾回收的主要对象" class="headerlink" title="1.垃圾回收的主要对象"></a>1.垃圾回收的主要对象</h1><p>程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程执行结束而消失，这几个区域的内存分配和回收都具备确定性，不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟着回收了。<strong>Java堆</strong>和<strong>方法区</strong>则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，只有在程序处于运行期间才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，<strong>垃圾收集器所关注的是这部分内容</strong>。</p><h1 id="2-怎样判断一个对象是否可以被回收"><a href="#2-怎样判断一个对象是否可以被回收" class="headerlink" title="2.怎样判断一个对象是否可以被回收"></a>2.怎样判断一个对象是否可以被回收</h1><p>在Java堆里面存放着几乎所有的Java实例，垃圾收集器在对堆收集之前，第一件事情是确定这些对象中哪些还“存活”，哪些对象已“死去”。</p><h3 id="2-1-引用计数算法-Reference-Counting"><a href="#2-1-引用计数算法-Reference-Counting" class="headerlink" title="2.1 引用计数算法(Reference Counting)"></a>2.1 引用计数算法(Reference Counting)</h3><p>给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。<br>引用计数算法实现简单，判定效率很高，但是Java虚拟机里面没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间循环引用的问题。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java垃圾收集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机内存布局</title>
      <link href="/2019/05/31/java-xu-ni-ji-nei-cun-bu-ju/"/>
      <url>/2019/05/31/java-xu-ni-ji-nei-cun-bu-ju/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Java虚拟机启动之后会以一个进程方式运行，Java虚拟机执行过程中会把它所管理的内存划分为了若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。不同版本的虚拟机规范以及不同版本的虚拟机都会有不同的规定及实现，这里以JDK1.6、1.7版本中的规定为准。(本文中的示意图均来自网络，感谢图片作者辛勤的劳动，这里我就不重复造轮子啦~)。</p></blockquote><h1 id="1-Java运行时数据区划分"><a href="#1-Java运行时数据区划分" class="headerlink" title="1.Java运行时数据区划分"></a>1.Java运行时数据区划分</h1><p>Java虚拟机所管理的内存将会包括以下几个运行时数据区域：<br><img src="https://test-1258680748.cos.ap-shanghai.myqcloud.com/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/1.png" width="50%" height="50%" div="" align="center/"><br>其中程序计数器、Java虚拟机栈和本地方法栈是线程私有的，堆、方法区是进程中的各线程共享的。</p><h1 id="2-程序计数器"><a href="#2-程序计数器" class="headerlink" title="2.程序计数器"></a>2.程序计数器</h1><p>程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。每个线程都有一个独立的程序计数器，因为各线程在切换时能执行正确的指令。另外，如果线程正在执行的是Native方法，计数器的值为空。</p><h1 id="3-Java虚拟机栈"><a href="#3-Java虚拟机栈" class="headerlink" title="3.Java虚拟机栈"></a>3.Java虚拟机栈</h1><ol><li>Java虚拟机栈是线程私有的，它的生命周期与线程相同，每个方法在执行的时候都会创建一个栈帧，里面用于存放局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用到执行完成的过程，都对应着一个栈帧在Java虚拟机栈中的入栈和出栈的过程。</li><li>局部变量表存放了编译期可知的各种基本数据类型(boolean,byte,int,float等)、对象引用。局部变量表所需的内存空间在编译期间就可以知道，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的。</li><li>Java虚拟机规范中，对该区域规定了两种异常情况：</li></ol><ul><li>线程请求的栈深度大于虚拟机所允许的深度，比如递归的层数过多，将抛出<code>StackOverflowError</code>异常。</li><li>栈进行动态扩展时无法申请到足够的内存，会抛出<code>OutOfMemoryError</code>异常。</li></ul><h1 id="4-本地方法栈"><a href="#4-本地方法栈" class="headerlink" title="4.本地方法栈"></a>4.本地方法栈</h1><p>本地方法栈与虚拟机栈所发挥的作用是很相似的，它们的区别就是本地方法栈是为虚拟机使用到的Native方法服务。本地方法栈同样会抛出Java虚拟机栈中的两种异常。</p><h1 id="5-Java堆"><a href="#5-Java堆" class="headerlink" title="5.Java堆"></a>5.Java堆</h1><p>对于大多数应用来说，Java堆是Java虚拟机所管理的内存中最大的一块。Java堆被所有的线程共享。此内存区域的唯一目的就是存放对象实例。<br>该区域是垃圾收集器管理的主要区域，所以也被称为”GC堆”。<br>因为现代的垃圾收集器基本都是采用的分代收集算法，其主要的思想是针对不同类型的对象采用不同的垃圾回收算法，所以Java堆还可以细分为：</p><ul><li>新生代(Young Generation)</li><li>老年代(Old Generation)</li></ul><p>Java堆可以处于物理上不连续的内存空间中，只要逻辑上能连续即可。堆可以是固定大小的，也可以是可扩展的：通过虚拟机参数<code>-Xms</code>(设置堆的初始值)和<code>-Xmx</code>(设置堆的最大值)控制。<br>当堆中没有内存完成实例分配并且堆也无法再扩展时，将会抛出<code>OutOfMemoryError</code>异常。</p><h1 id="6-方法区"><a href="#6-方法区" class="headerlink" title="6.方法区"></a>6.方法区</h1><p>方法区是各线程共享的内存区域，用于存储已经被虚拟机加载的类信息、常量、静态变量、即使编译器编译后的代码等数据。<br>Java虚拟机规范把方法区描述为堆的一个逻辑部分。和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出<code>OutOfMemoryError</code>异常。<br>垃圾收集行为在这个区域是比较少出现的，该区域的内存回收目标主要是针对常量池的回收和对类的卸载。<br>HotSpot虚拟机把它当成永久代来进行垃圾回收。但是很难确定永久代的大小，因为它受到很多因素影响，并且每次Full GC之后永久代的大小都会改变，所以经常会抛出<code>OutOfMemoryError</code>异常。为了更容易管理方法区，从JDK1.8开始,移除永久代,并把方法区移至元空间,它位于本地内存中,而不是虚拟机内存中。<br>方法区是一个JVM规范，永久代和元空间都是它的一种实现方式。在JDK1.8之后,原来永久代的数据被分到了堆和元空间中。元空间存储类的原信息，静态变量和常量池等放入堆中。</p><h1 id="7-运行时常量池"><a href="#7-运行时常量池" class="headerlink" title="7.运行时常量池"></a>7.运行时常量池</h1><p>该区域是方法区的一部分。Class文件中的常量池(用于存放编译期生成的各种字面量和符号引用)中的内容会在类加载后放入方法区的运行时常量池。还有就是运行期间也可以将新的常量放入常量池中，例如String.intern()。<br>当常量池无法申请到内存时会抛出<code>OutOfMemoryError</code>异常。</p><h1 id="8-直接内存"><a href="#8-直接内存" class="headerlink" title="8.直接内存"></a>8.直接内存</h1><p>直接内存不是虚拟机的运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分区域也会被经常使用，并且也可能导致<code>OutOfMemoryError</code>异常。<br>JDK1.4新加入了NIO,引入了基于通道Channel)和缓冲区(Buffer)的I/O方式，它可以使用native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。因为避免了在Java堆和Native堆中来回复制数据，所以能在一些应用场景中显著提高性能。<br>本地内存不受Java堆大小的限制，但是也会受到本机内存大小以及处理器寻址空间的限制。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java容器-HashMap(JDK1.7)</title>
      <link href="/2019/05/30/java-rong-qi-hashmap/"/>
      <url>/2019/05/30/java-rong-qi-hashmap/</url>
      
        <content type="html"><![CDATA[<h1 id="1-声明"><a href="#1-声明" class="headerlink" title="1.声明"></a>1.声明</h1><p>HashMap类的声明如下：<br>&ensp;<code>public class HashMap&lt;K,V&gt;    extends AbstractMap&lt;K,V&gt;    implements Map&lt;K,V&gt;, Cloneable, Serializable</code><br>从它的声明中可以看出HashMap继承了AbstractMap类，实现了Map等接口。Map接口中主要是声明了一些抽象方法以及一个内部接口：<code>interface Entry&lt;K,V&gt;</code>,还有一些默认方法的定义。</p><h1 id="2-HashMap的内部存储结构"><a href="#2-HashMap的内部存储结构" class="headerlink" title="2.HashMap的内部存储结构"></a>2.HashMap的内部存储结构</h1><p>在HashMap对象中，有一个Entry&lt;K,V&gt;类型的数组：<code>transient Entry&lt;K,V&gt;[] table</code>，其中Entry类是HashMap的静态内部类，它实现了Map接口中的内部接口Entry:<code>static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt;</code>。Entry定义如下:</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> K key<span class="token punctuation">;</span>        V value<span class="token punctuation">;</span>        Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span>        <span class="token keyword">int</span> hash<span class="token punctuation">;</span>        <span class="token function">Entry</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">,</span> K k<span class="token punctuation">,</span> V v<span class="token punctuation">,</span> Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>            value <span class="token operator">=</span> v<span class="token punctuation">;</span>            next <span class="token operator">=</span> n<span class="token punctuation">;</span>            key <span class="token operator">=</span> k<span class="token punctuation">;</span>            hash <span class="token operator">=</span> h<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> K <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> key<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> V <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> value<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> V <span class="token function">setValue</span><span class="token punctuation">(</span>V newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>            V oldValue <span class="token operator">=</span> value<span class="token punctuation">;</span>            value <span class="token operator">=</span> newValue<span class="token punctuation">;</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>o <span class="token keyword">instanceof</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            Map<span class="token punctuation">.</span>Entry e <span class="token operator">=</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token punctuation">)</span>o<span class="token punctuation">;</span>            Object k1 <span class="token operator">=</span> <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Object k2 <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>k1 <span class="token operator">==</span> k2 <span class="token operator">||</span> <span class="token punctuation">(</span>k1 <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> k1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                Object v1 <span class="token operator">=</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                Object v2 <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>v1 <span class="token operator">==</span> v2 <span class="token operator">||</span> <span class="token punctuation">(</span>v1 <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> v1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>v2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> Objects<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> Objects<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"="</span> <span class="token operator">+</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">void</span> <span class="token function">recordAccess</span><span class="token punctuation">(</span>HashMap<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>        <span class="token keyword">void</span> <span class="token function">recordRemoval</span><span class="token punctuation">(</span>HashMap<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>从Entry的定义可以看出，它包含了4个字段，其中key和value里面存储的是键值对，next字段指向下一个Entry,所以多个Entry可以组成一个链表。</p><h1 id="3-HashMap中重要变量及方法"><a href="#3-HashMap中重要变量及方法" class="headerlink" title="3.HashMap中重要变量及方法"></a>3.HashMap中重要变量及方法</h1><h3 id="3-1-变量"><a href="#3-1-变量" class="headerlink" title="3.1 变量"></a>3.1 变量</h3><ol><li><strong><code>final float loadFactor;</code></strong>装载因子，代表了table的填充度，如果在构造函数中不指定它的值，默认为<code>static final float DEFAULT_LOAD_FACTOR = 0.75f;</code>;</li><li><strong><code>transient int size;</code></strong>实际存储的key-value对的数量;</li><li><strong><code>int threshold;</code></strong>阈值，table容量，在构造函数中不指定它的值，默认为<code>static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;</code>,也就是16。当table被填充后，该值一般为capacity*loadFactory。HashMap在扩容是需要用到threshold。</li><li><code>transient int modCount;</code>这个和ArrayList中对应变量的作用一样。</li></ol><h3 id="3-2-方法"><a href="#3-2-方法" class="headerlink" title="3.2 方法"></a>3.2 方法</h3><ol><li><p><strong>构造器</strong>：HashMap有4个构造器，其他3个构造器都会调用下面这个构造器</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>         <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal initial capacity: "</span> <span class="token operator">+</span>                                            initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">></span> MAXIMUM_CAPACITY<span class="token punctuation">)</span>         initialCapacity <span class="token operator">=</span> MAXIMUM_CAPACITY<span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>loadFactor <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> Float<span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span>loadFactor<span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal load factor: "</span> <span class="token operator">+</span>                                            loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> loadFactor<span class="token punctuation">;</span>     threshold <span class="token operator">=</span> initialCapacity<span class="token punctuation">;</span>     <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//init()方法在HashMap中是空方法</span> <span class="token punctuation">}</span></code></pre><p>从代码可以看出，在构造器中没有为对数组table进行操作，构建数组的操作实在put()方法中进行的。</p></li><li><p><strong>put()</strong>：</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>table <span class="token operator">==</span> EMPTY_TABLE<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token function">inflateTable</span><span class="token punctuation">(</span>threshold<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token comment" spellcheck="true">//键为null时单独处理</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span>         <span class="token keyword">return</span> <span class="token function">putForNullKey</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//确定桶下标</span>     <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//先找出是否已经存在键为key的Entry，如果存在，说明之前插入过相同键的Entry，就更新具有相同key的Entry的value为新put进的value值</span>     <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> null<span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>         Object k<span class="token punctuation">;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>             V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>             e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>             e<span class="token punctuation">.</span><span class="token function">recordAccess</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>         <span class="token punctuation">}</span>     <span class="token punctuation">}</span>     modCount<span class="token operator">++</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//插入新的键值对</span>     <span class="token function">addEntry</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> null<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p><code>EMPTY_TABLE</code>是HashMap的静态常量，是一个空的Entry数组。在创建HashMap对象的时候，table就是被赋值为它的：<code>transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</code>。第一次的put操作，会调用inflateTable方法，创建数组table:</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">inflateTable</span><span class="token punctuation">(</span><span class="token keyword">int</span> toSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// Find a power of 2 >= toSize</span>     <span class="token keyword">int</span> capacity <span class="token operator">=</span> <span class="token function">roundUpToPowerOf2</span><span class="token punctuation">(</span>toSize<span class="token punctuation">)</span><span class="token punctuation">;</span>     threshold <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>capacity <span class="token operator">*</span> loadFactor<span class="token punctuation">,</span> MAXIMUM_CAPACITY <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     table <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span>capacity<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token function">initHashSeedAsNeeded</span><span class="token punctuation">(</span>capacity<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">roundUpToPowerOf2</span><span class="token punctuation">(</span><span class="token keyword">int</span> number<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// assert number >= 0 : "number must be non-negative";</span>     <span class="token keyword">return</span> number <span class="token operator">>=</span> MAXIMUM_CAPACITY             <span class="token operator">?</span> MAXIMUM_CAPACITY             <span class="token operator">:</span> <span class="token punctuation">(</span>number <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">?</span> Integer<span class="token punctuation">.</span><span class="token function">highestOneBit</span><span class="token punctuation">(</span><span class="token punctuation">(</span>number <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>在inflateTable方法中调用了roundUpToPowerOf2方法，在这个方法中，Integer.highestOneBit返回最左边为1其余位都为0的二进制数，因此roundUpToPowerOf2方法返回一个不小于number的最小的数，这个数是2的整数次幂。比如：如果创建HashMap时不指定容量，第一次put操作就会使table的大小为16.<br>之后会根据要put进键值对的key计算hash值及对应的table索引，如果这个key之前就插入过，则更新之前的value值为新插入的value值并返回；如果之前没有插入过这个key，则会调用addEntry插入:</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">void</span> <span class="token function">addEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">int</span> bucketIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">>=</span> threshold<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token function">resize</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>         hash <span class="token operator">=</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> key<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>         bucketIndex <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token function">createEntry</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> bucketIndex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">void</span> <span class="token function">createEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">int</span> bucketIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>     Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>     table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>     size<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>在createEntry中，很明显是一个在链表中插入结点的操作：新建一个指向下一个Entry的Entry，并使当前节点指向新建的Entry。</p></li><li><p><strong>hash()</strong><br>hash数据结构少不了计算数据的hash值，在put方法中也已经看到，在把新的数据元素放入table之前就要先根据key计算hash值:</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>Object k<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">int</span> h <span class="token operator">=</span> hashSeed<span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">!=</span> h <span class="token operator">&amp;&amp;</span> k <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">return</span> sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>Hashing<span class="token punctuation">.</span><span class="token function">stringHash32</span><span class="token punctuation">(</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     h <span class="token operator">^=</span> k<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// This function ensures that hashCodes that differ only by</span>     <span class="token comment" spellcheck="true">// constant multiples at each bit position have a bounded</span>     <span class="token comment" spellcheck="true">// number of collisions (approximately 8 at default load factor).</span>     h <span class="token operator">^=</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>如果key是字符串并且hashSeed不为0，就单独处理。否则，该函数先调用k自身的hashCode方法计算出一个hash值h，又经过移位和异或运算进一步计算hash值。</p></li><li><strong>indexFor()</strong><br>该方法用于根据hash值确定在table中的位置：<pre class=" language-java"><code class="language-java"> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">indexFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2";</span>     <span class="token keyword">return</span> h <span class="token operator">&amp;</span> <span class="token punctuation">(</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre>当length为2的整数次幂时(HashMap中table的长度就是2的整数次幂),<code>h &amp; (length-1)</code>其实是<code>h%length</code>，也就是取余，但是位运算的性能要优于算术运算。</li><li><p><strong>resize()</strong><br>设HashMap的table长度为M,需要存储的键值对数量为N。如果哈希函数满足均匀性的要求，那么table每个位置上的链表的长度大约为N/M,因此平均查找次数的复杂度为O(N/M)。<br>为了让查找的成本更低，应该尽可能使得N/M尽可能小，也就是需要保证M尽可能大。HashMap采用动态扩容的方法根据当前的N值调整M值，使得空间效率和时间效率都能得到保证。<br>在<code>addEntry</code>方法中，如果当前Entry的数量已经大于阈值<code>threshold</code>并且本次插入出现了hash碰撞，就要对table进行扩容:<code>resize(2 * table.length)</code>,使其为<br>原来长度的2倍。</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">void</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token keyword">int</span> newCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>     Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> oldTable <span class="token operator">=</span> table<span class="token punctuation">;</span>     <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> oldTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">==</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">{</span>         threshold <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>         <span class="token keyword">return</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token comment" spellcheck="true">//根据新的容量创建新的table</span>     Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> newTable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span>newCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//将原table中的Entry转移到新的table中</span>     <span class="token function">transfer</span><span class="token punctuation">(</span>newTable<span class="token punctuation">,</span> <span class="token function">initHashSeedAsNeeded</span><span class="token punctuation">(</span>newCapacity<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     table <span class="token operator">=</span> newTable<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//更新阈值</span>     threshold <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>newCapacity <span class="token operator">*</span> loadFactor<span class="token punctuation">,</span> MAXIMUM_CAPACITY <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span>Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> newTable<span class="token punctuation">,</span> <span class="token keyword">boolean</span> rehash<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> newTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//对于原table中的各个Entry，重新计算在新table中的位置并加入新table中</span>     <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">:</span> table<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">while</span><span class="token punctuation">(</span>null <span class="token operator">!=</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>             Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>             <span class="token keyword">if</span> <span class="token punctuation">(</span>rehash<span class="token punctuation">)</span> <span class="token punctuation">{</span>                 e<span class="token punctuation">.</span>hash <span class="token operator">=</span> null <span class="token operator">==</span> e<span class="token punctuation">.</span>key <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token function">hash</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token punctuation">}</span>             <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>             e<span class="token punctuation">.</span>next <span class="token operator">=</span> newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>             newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>             e <span class="token operator">=</span> next<span class="token punctuation">;</span>         <span class="token punctuation">}</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p>由于要逐个复制Entry，所以resize操作使很费时的。</p></li><li><strong>putForNullKey()</strong><br>这个方法在put方法中出现过，它的作用是处理插入的键值对中的键为null时的情形。<pre class=" language-java"><code class="language-java"> <span class="token keyword">private</span> V <span class="token function">putForNullKey</span><span class="token punctuation">(</span>V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> null<span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>             V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>             e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>             e<span class="token punctuation">.</span><span class="token function">recordAccess</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>         <span class="token punctuation">}</span>     <span class="token punctuation">}</span>     modCount<span class="token operator">++</span><span class="token punctuation">;</span>     <span class="token function">addEntry</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> null<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> null<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre>HashMap允许插入键为null的键值对。但是因为null没有hashCode()方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标的方式来存放。从for循环以及addEntry的参数可以看出：HashMap使用第0个桶(table[0])存放键为null的键值对，当然table[0]处不是只有键为null的Entry。</li><li><p><strong>remove()</strong><br><code>remove()</code>方法用于根据给定的key移除table中对应的Entry：</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> V <span class="token function">remove</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>     Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> <span class="token function">removeEntryForKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> null <span class="token operator">?</span> null <span class="token operator">:</span> e<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">final</span> Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">removeEntryForKey</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">return</span> null<span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>     Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> prev <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>     Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> prev<span class="token punctuation">;</span>     <span class="token keyword">while</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>         Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>         Object k<span class="token punctuation">;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>             <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>             modCount<span class="token operator">++</span><span class="token punctuation">;</span>             size<span class="token operator">--</span><span class="token punctuation">;</span>             <span class="token keyword">if</span> <span class="token punctuation">(</span>prev <span class="token operator">==</span> e<span class="token punctuation">)</span>                 table<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> next<span class="token punctuation">;</span>             <span class="token keyword">else</span>                 prev<span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>             e<span class="token punctuation">.</span><span class="token function">recordRemoval</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token keyword">return</span> e<span class="token punctuation">;</span>         <span class="token punctuation">}</span>         prev <span class="token operator">=</span> e<span class="token punctuation">;</span>         e <span class="token operator">=</span> next<span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">return</span> e<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>该方法先确定给定key的hash值，进而得到在table中的位置，然后遍历链表，删除对应的Entry并返回，最后返回该Entry中的value。另外，可以看到remove操作没有改变table的长度。</p></li><li><p><strong>get()</strong><br><code>get()</code>方法用于根据给定key得到table中它对应的value：</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span>         <span class="token keyword">return</span> <span class="token function">getForNullKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> entry <span class="token operator">=</span> <span class="token function">getEntry</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> null <span class="token operator">==</span> entry <span class="token operator">?</span> null <span class="token operator">:</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">private</span> V <span class="token function">getForNullKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">return</span> null<span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> null<span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span>             <span class="token keyword">return</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">return</span> null<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">final</span> Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">getEntry</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">return</span> null<span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span><span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>          e <span class="token operator">!=</span> null<span class="token punctuation">;</span>          e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>         Object k<span class="token punctuation">;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>             <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>             <span class="token keyword">return</span> e<span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">return</span> null<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>可以看出：当key为null时，遍历table[0]指向的Entry链表；当key不为null时，<br>根据key计算hash以及在table中的位置，接着就是遍历table[i]中的链表。在找到对应的Entry时，返回Entry进而得到key对应的value。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> JDK源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java容器__ArrayList</title>
      <link href="/2019/05/24/java-rong-qi-arraylist/"/>
      <url>/2019/05/24/java-rong-qi-arraylist/</url>
      
        <content type="html"><![CDATA[<h1 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h1><p>ArrayList类的定义如下：<br>&ensp;<code>public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</code><br>从它的定义中可以看出ArrayList继承自AbstractList类，实现了List接口。List接口是Collection接口的子接口，它规定了实现该接口的类是一个元素有序、可重复的集合，集合中的每个元素都有其对应的顺序索引，它默认按元素的添加顺序设置元素的索引，比如：第一次添加的元素索引为0，第二次的为1……<br>RandomAccess、Serializable和Cloneable接口都是空接口。RandomAccess表示ArrayList可以在常数时间内完成随机存取以便使用者可以根据需求选择合适的集合，Serializable接口表示ArrayList对象可以序列化，而Cloneable接口表示ArrayList对象可以调用Object类的clone()方法并不会抛出异常。</p><h1 id="2-主要成员变量"><a href="#2-主要成员变量" class="headerlink" title="2.主要成员变量"></a>2.主要成员变量</h1><p>ArrayList类中的成员变量主要有以下几个：<br>1.存放数据的Object数组elementData，ArrayList基于数组实现就保证了它可以在常数的时间内完成随机存取：<br>&ensp;<code>transient Object[] elementData;</code><br>2.ArrayList对象默认的初始容量：<br>&ensp;<code>private static final int DEFAULT_CAPACITY = 10;</code><br>3.ArrayList的容量size，size是私有的实例变量，不允许在ArrayList对象之外访问，只能通过public的size()方法访问：<br>&ensp;<code>private int size;</code><br>4.ArrayList的最大容量：<br>&ensp;<code>private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</code><br>其它变量可以自行查看ArrayList.java文件。</p><h1 id="3-ArrayList常用方法的实现"><a href="#3-ArrayList常用方法的实现" class="headerlink" title="3.ArrayList常用方法的实现"></a>3.ArrayList常用方法的实现</h1><h3 id="3-1添加元素–add"><a href="#3-1添加元素–add" class="headerlink" title="3.1添加元素–add()"></a>3.1添加元素–add()</h3><p>add()方法有两个重载的形式：<br>1.第一个是不用提供索引的add():</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Increments modCount!!</span>        elementData<span class="token punctuation">[</span>size<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>以要添加进集合的元素为参数调用该方法，首先会确保elementData数组的容量，之后在elementData数组的最后加入该元素，如果成功加入则返回true.<br>2.第二个是在某个确定的位置加入元素的add():</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> E element<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">rangeCheckForAdd</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Increments modCount!!</span>        System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>                         size <span class="token operator">-</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>        elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>        size<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>这个方法除了要提供要添加的元素，还要提供该元素放入的位置index。该方法首先核对index的合法性和element数组的大小；接着调用System类的静态方法arraycopy()方法，将需要挪动的元素移动到相应的位置，arrayCopy()方法是native的，应该是使用c++实现的；最后把需要添加的元素放入相应的位置并且容量加1。</p><h3 id="3-2扩容–grow"><a href="#3-2扩容–grow" class="headerlink" title="3.2扩容–grow()"></a>3.2扩容–grow()</h3><p>当添加元素之前，会使用ensureCapacityInternal()方法来确保elementData数组容量充足。如果不够，需要使用grow()方法进行扩容。</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData <span class="token operator">==</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">)</span> <span class="token punctuation">{</span>            minCapacity <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>DEFAULT_CAPACITY<span class="token punctuation">,</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// overflow-conscious code</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">-</span> elementData<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">grow</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// overflow-conscious code</span>        <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            newCapacity <span class="token operator">=</span> minCapacity<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> MAX_ARRAY_SIZE <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>            newCapacity <span class="token operator">=</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// minCapacity is usually close to size, so this is a win:</span>        elementData <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// overflow</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">OutOfMemoryError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">></span> MAX_ARRAY_SIZE<span class="token punctuation">)</span> <span class="token operator">?</span>            Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">:</span>            MAX_ARRAY_SIZE<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>1.<code>ensureCapacityInternal(int minCapacity)</code>方法中的<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>是ArrayList类的静态常量，是一个空的Object数组。从该方法的前三行代码可以看出首次为ArrayList对象添加数据时，会是它的容量变为10。<br>2.<code>ensureExplicitCapacity(int minCapacity)</code>方法会比较需要的最小容量<code>minCapacity</code>和当前ArrayList容量<code>elementData.length</code>的大小，如果需要的容量大于当前的容量，则需要扩容。<br>3.<code>private void grow(int minCapacity)</code>方法就是扩容的实现。<code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</code>表明新的容量是旧容量的1.5倍。接下来的两行应该是防止oldCapacity右移一位后变为0或负数。<code>newCapacity = hugeCapacity(minCapacity);</code>确保minCapacity已经很大时，newCapacity不会超过数组大小的极限。得到了需要的容量之后，调用Arrays的copy()方法，这个方法会新建一个数组，并将原来的数组中的元素都拷贝进新的数组，返回新的数组，拷贝数组依然是通过System.arrayCopy()方法实现。扩容操作需要把原数组整个的复制到新数组中，这个操作代价很高，所以在创建ArrayList对象的时候最好指定大概的容量，从而减少扩容操作的次数。</p><h3 id="3-3删除元素–remove"><a href="#3-3删除元素–remove" class="headerlink" title="3.3删除元素–remove()"></a>3.3删除元素–remove()</h3><p>ArrayList中有两种形式的remove():</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> E <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">rangeCheck</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>        E oldValue <span class="token operator">=</span> <span class="token function">elementData</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> numMoved <span class="token operator">=</span> size <span class="token operator">-</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>numMoved <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>            System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span>                             numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span>        elementData<span class="token punctuation">[</span><span class="token operator">--</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// clear to let GC do its work</span>        <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">fastRemove</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">fastRemove</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">fastRemove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> numMoved <span class="token operator">=</span> size <span class="token operator">-</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>numMoved <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>            System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span>                             numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span>        elementData<span class="token punctuation">[</span><span class="token operator">--</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// clear to let GC do its work</span>    <span class="token punctuation">}</span></code></pre><p><code>public E remove(int index)</code>是删除索引处的元素；<br><code>public boolean remove(Object o)</code>是删除集合中第一个与Object相等的元素；<br>从代码可以看出：每次删除都要计算出需要移动的元素数目，也就是删除元素之后的元素的数目，然后调用System.arrcopy()方法将index+1及后面位置的所有元素都复制到index位置上，这个操作的复杂度为O(size)。</p><h3 id="3-4Fail-Fast机制"><a href="#3-4Fail-Fast机制" class="headerlink" title="3.4Fail-Fast机制"></a>3.4Fail-Fast机制</h3><p>ArrayList对象中有一个继承自AbstractList的变量<code>protected transient int modCount = 0;</code>，modCount用来记录ArrayList结构发生变化的次数。比如上面的add和remove，还有调整内部数组的大小，都会是modCount变化。在进行序列化或者迭代等操作的时候，需要比较操作前后modCount是否发生变化，如果modCount改变了，就要抛出ConcurrentModificationException。下面用两个线程演示一下这个现象：</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayListTest</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> ArrayList<span class="token operator">&lt;</span>String<span class="token operator">></span> test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ArrayListTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">50</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>test<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">class</span> <span class="token class-name">TraversalThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span><span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//遍历ArrayList</span>            <span class="token comment" spellcheck="true">//synchronized(ArrayListTest.this.test){</span>                Iterator iterator <span class="token operator">=</span> ArrayListTest<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>test<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">class</span> <span class="token class-name">ModifyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span><span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//修改ArrayList</span>            ArrayListTest<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>test<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        ArrayListTest arrayListTest <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayListTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        TraversalThread traversalThread <span class="token operator">=</span> arrayListTest<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">TraversalThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ModifyThread modifyThread <span class="token operator">=</span> arrayListTest<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">ModifyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//traversalThread.setPriority(5);</span>        <span class="token comment" spellcheck="true">//modifyThread.setPriority(10);</span>        traversalThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        modifyThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>线程traversalThread和线程modifyThread会对同一个Arraylist对象进行访问，前者遍历集合，后者向集合中添加一个元素。代码的运行结果为：</p><p><div align="center/"><img src="https://test-1258680748.cos.ap-shanghai.myqcloud.com/Java%E9%9B%86%E5%90%88_ArrayList/ArrayList_1.PNG" alt="" title="result1"></div></p><p><div align="center/"><img src="https://test-1258680748.cos.ap-shanghai.myqcloud.com/Java%E9%9B%86%E5%90%88_ArrayList/ArrayList_2.PNG" alt="" title="result2"></div></p><p><div align="center/"><img src="https://test-1258680748.cos.ap-shanghai.myqcloud.com/Java%E9%9B%86%E5%90%88_ArrayList/ArrayList_3.PNG" alt="" title="result3"><br>图1和图3都是先遍历，在遍历的过程中出现了修改ArrayList对象的操作，所以出现了异常。图2是先修改然后再遍历，没有异常。出现异常的原因就是内部类Itr(该类就是ArrayList的Iterator)的next()方法会检查modCount变量，modCount发生变化就会抛出ConcurrentModificationException异常。</div></p>]]></content>
      
      
      <categories>
          
          <category> Java集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> JDK源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java数组和集合的遍历方法</title>
      <link href="/2019/05/23/java-shu-zu-he-ji-he-de-bian-li-fang-fa/"/>
      <url>/2019/05/23/java-shu-zu-he-ji-he-de-bian-li-fang-fa/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Java遍历数组可以使用<strong>普通的for循环</strong>，也可以使用<strong>增强的for循环</strong>；而Java遍历集合元素的方法有：增强for循环，使用集合的iterator等。</p></blockquote><h1 id="1-数组的遍历"><a href="#1-数组的遍历" class="headerlink" title="1.数组的遍历"></a>1.数组的遍历</h1><h3 id="1-1-普通for循环"><a href="#1-1-普通for循环" class="headerlink" title="1.1 普通for循环"></a>1.1 普通for循环</h3><p>   这种遍历方法是设置一个循环变量，将循环变量作为数组的索引依次访问数组中的每个元素。</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="1-2-增强的for循环"><a href="#1-2-增强的for循环" class="headerlink" title="1.2 增强的for循环"></a>1.2 增强的for循环</h3><p>从jdk1.5中引入的增强for循环可以不用设置循环变量，简化了代码的编写。</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> e <span class="token operator">:</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h1 id="2-集合的遍历"><a href="#2-集合的遍历" class="headerlink" title="2.集合的遍历"></a>2.集合的遍历</h1><h3 id="2-1-使用增强的for循环"><a href="#2-1-使用增强的for循环" class="headerlink" title="2.1 使用增强的for循环"></a>2.1 使用增强的for循环</h3><p>这个应该是比较常用的方法。使用方法为：</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">for</span><span class="token punctuation">(</span>Type value <span class="token operator">:</span> Iterable<span class="token punctuation">)</span><span class="token punctuation">{</span>        expression value<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>注意Iterable，这是集合可以使用增强for循环遍历元素的前提，也就是说集合必须实现Iterable接口之后才可以使用增强的for循环。</p><h3 id="2-2-使用Iterator"><a href="#2-2-使用Iterator" class="headerlink" title="2.2 使用Iterator"></a>2.2 使用Iterator</h3><p>先看Java集合的父接口-Collection接口的定义：<br>&ensp;<code>public interface Collection&lt;E&gt; extends Iterable&lt;E&gt;</code><br>可以看到Collection接口继承了Iterable接口，那Iterable接口是什么呢？它的定义如下<br>&ensp;<code>public interface Iterable&lt;T&gt;</code><br>在Iterable接口中有一个抽象方法：<br>&ensp;<code>Iterator&lt;T&gt; iterator();</code><br>iterator()方法返回一个Iterarot，那Iterator是什么？它的定义如下:<br>&ensp;<code>public interface Iterator&lt;E&gt;</code><br>Iterator接口中的抽象方法有两个:</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    E <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>根据方法的名字，可以大致了解它的功能：<br>hasNext()方法为boolean类型，它在遍历集合的时候会返回是否还有未遍历的元素；<br>next()方法返回一个E类型的元素，它会返回一个集合中还未遍历的元素。<br>Collection接口没有实现从Iterable接口继承过来的iterator()抽象方法，iterator的实现均放在了具体的某个集合类的定义中。下面以ArrayList为例，看一下Iterator的实现：</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> Iterator<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Itr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Itr</span> <span class="token keyword">implements</span> <span class="token class-name">Iterator</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> cursor<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// index of next element to return</span>        <span class="token keyword">int</span> lastRet <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// index of last element returned; -1 if no such</span>        <span class="token keyword">int</span> expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> cursor <span class="token operator">!=</span> size<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>        <span class="token keyword">public</span> E <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> cursor<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> size<span class="token punctuation">)</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elementData <span class="token operator">=</span> ArrayList<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>elementData<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">)</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            cursor <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span>E<span class="token punctuation">)</span> elementData<span class="token punctuation">[</span>lastRet <span class="token operator">=</span> i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span></code></pre><p>可以看到是ArrayList是定义了一个内部类Itr实现了Iterator接口，而iterator方法返回了该类的一个实例，其中的elementData就是ArrayList对象保存数据用的Object类型的数组，size是该数组的大小。<br>所以要遍历ArrayList对象中的元素，可以先获得该对象的迭代器，然后使用hasNext()和next()两个方法实现对它的遍历：</p><pre class=" language-java"><code class="language-java">    List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"spring"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"springMVC"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"MyBatis"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Iterator<span class="token operator">&lt;</span>String<span class="token operator">></span> i <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="2-3-两种遍历集合方法的比较"><a href="#2-3-两种遍历集合方法的比较" class="headerlink" title="2.3 两种遍历集合方法的比较"></a>2.3 两种遍历集合方法的比较</h3><p>其实增强的for循环的内部实现就是使用的集合对象的iterator，这种循环的优点是代码更简洁，缺点是：<br>1.只能顺次遍历所有元素，无法实现较为复杂的循环，如在某些条件下需要后退到之前遍历过的元素；<br>2.循环变量i不可见，无法得知当前遍历到数组的第几个元素。</p><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h1><p>虽然增强的for循环会被编译器转化为iterator操作，但是使用增强的for循环时，iterator是不可见的，所以如果需要调用iterator的remove()方法或是其他一些操作，就有些力不从心了。所以，Java 5.0提供的增强的for循环能让我们的代码更简洁，可以让我们更加方便的使用iterator，但是它也是有局限性的，所以要根据实际情况有选择的使用。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK源码 </tag>
            
            <tag> Java集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java类加载机制</title>
      <link href="/2019/05/14/java-lei-jia-zai-ji-zhi/"/>
      <url>/2019/05/14/java-lei-jia-zai-ji-zhi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>我们编写的Java代码（.java文件）经过编译之后，生成.class文件，.class文件中描述了这个类的各种信息。而这些信息最终都需要加载到虚拟机中之后才能运行和使用。虚拟机把描述类的数据从.class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。</p></blockquote><h1 id="1、类的生命周期"><a href="#1、类的生命周期" class="headerlink" title="1、类的生命周期"></a>1、类的生命周期</h1><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，整个生命周期包括：<strong>加载、验证、准备、解析、使用</strong>和<strong>卸载</strong>，如图所示。其中解析阶段可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定。  </p><p><div align="center/"><img src="https://test-1258680748.cos.ap-shanghai.myqcloud.com/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/%E7%BB%98%E5%9B%BE1.jpg" alt="" title="类的生命周期"></div></p><h1 id="2、类的加载过程"><a href="#2、类的加载过程" class="headerlink" title="2、类的加载过程"></a>2、类的加载过程</h1><h3 id="2-1-加载"><a href="#2-1-加载" class="headerlink" title="2.1 加载"></a>2.1 加载</h3><p>加载是类加载中的一个阶段，这个阶段完成以下三件事:    </p><ul><li>通过类的完全限定名获取定义这个类的二进制字节流  </li><li>将该字节流表示的静态存储结构转换为方法区的运行时存储结构    </li><li>在内存中生成一个代表该类的Class对象，作为方法区中该类各种数据的访问入口</li></ul><p>其中的二进制字节流获取方式可以是:    </p><ul><li>从zip包中读取，这是使用JAR、EAR、WAR格式的基础    </li><li>从网络中获取，最典型的应用是Applet</li><li>运行时生成，比如动态代理技术，在java.lang.reflect.Proxy使用ProxyGenerator.generateProxyClass的代理类的二进制字节流</li><li>由其它文件生成，例如由JSP文件生成对应的Class类</li></ul><h3 id="2-2-验证"><a href="#2-2-验证" class="headerlink" title="2.2 验证"></a>2.2 验证</h3><p>确保.class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><h3 id="2-3-准备"><a href="#2-3-准备" class="headerlink" title="2.3 准备"></a>2.3 准备</h3><p><strong>为类变量(被static修饰的变量)分配内存</strong>并<strong>设置类变量初始值</strong>的阶段，这些类变量所使用的内存都将在<strong>方法区</strong>中进行分配。</p><p>(1)这个阶段进行<strong>内存分配的只包括类变量</strong>，不包括实例变量，实例变量是在类实例化时随着对象一起分配在Java堆中；<br>(2)类变量在这个阶段一般被初始化为0值，比如类变量value被初始化为0而不是321<br>&ensp;<code>public statuc int value = 321;</code><br>如果类变量是常量，那么它将被初始化为表达式所声明的值，比如下面的常量value被初始化为321<br>&ensp;<code>public static final int value = 321;</code></p><h3 id="2-4-解析"><a href="#2-4-解析" class="headerlink" title="2.4 解析"></a>2.4 解析</h3><p>将.class文件中的常量池中的符号引用替换为直接引用。</p><h3 id="2-5-初始化"><a href="#2-5-初始化" class="headerlink" title="2.5 初始化"></a>2.5 初始化</h3><p>初始化是类加载过程的最后一步，前面的几步，除了在加载阶段用户可以编写程序参与之外，其余都是由虚拟机主导完成的。<br>在初始化阶段，才真正开始执行该类中编写的Java代码。在这个阶段中，执行类构造器的<strong>&lt;clinit&gt;()方法</strong>，这个方法是由编译器自动收集类中的所有类变量的赋值语句和静态初始化块中的语句合并产生的。编译器收集的顺序是由语句在源文件中出现的顺序决定的。<br>静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。比如下面代码：    </p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>    <span class="token keyword">static</span><span class="token punctuation">{</span>        i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//给变量i赋值可以正常编译通过</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//这句编译器会提示“非法向前引用”</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java类加载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TensorRT的安装与使用</title>
      <link href="/2019/02/24/tensorrt-de-an-zhuang-yu-shi-yong/"/>
      <url>/2019/02/24/tensorrt-de-an-zhuang-yu-shi-yong/</url>
      
        <content type="html"><![CDATA[<blockquote><p>深度学习应用需要使用预训练的模型进行推理。而使用主流深度学习框架训练出的神经网络模型因保存了巨额的参数而占据了极大的存储空间，例如经典的图像分类模型Alexnet模型就有超过了200M。除此之外，直接使用深度学习框架进行推理，往往会耗费较多的时间，造成很大的时延，这对于某些对时延要求苛刻的深度学习应用（比如自动驾驶、视频监控等）是不可行的。</p></blockquote><h1 id="1、TensorRT介绍"><a href="#1、TensorRT介绍" class="headerlink" title="1、TensorRT介绍"></a>1、TensorRT介绍</h1><p>NVIDIA公司的TensorRT是一款高性能深度学习推理平台。它为深度学习推理应用提供了推理优化器和运行时。在推理过程中，与只在运行在CPU平台上的应用相比，基于TensorRT的应用表现出超过40倍的加速比。使用TensorRT，你可以优化在所有主流框架下训练出的神经网络模型、调整到更低的精确的的同时保持高精度推理并且最终部署到超大规模数据中心、嵌入式或自动驾驶平台。<br><img src="https://test-1258680748.cos.ap-shanghai.myqcloud.com/TensorRT%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/1.png" alt=""></p><h1 id="2、TensorRT的安装"><a href="#2、TensorRT的安装" class="headerlink" title="2、TensorRT的安装"></a>2、TensorRT的安装</h1><p>官网提供了多种安装方式，我选择了Tar File的安装方式。首先要<a href="https://developer.nvidia.com/nvidia-tensorrt-5x-download" target="_blank" rel="noopener">下载安装包</a>，下载的时候需要nvidia的开发者账号，登陆之后可以下载。根据已经安装的CUDA的版本选择对应的TensorRT的安装包，假设电脑上已经安装CUDA9.0以及cudnn7.3。<br><img src="https://test-1258680748.cos.ap-shanghai.myqcloud.com/TensorRT%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/2.jpg" alt=""><br>下载完成之后，将下载的文件TensorRT-5.0.2.6.Ubuntu-16.04.4.x86_64-gnu.cuda-9.0.cudnn7.3.tar.gz移动到/home目录下，用tar命令进行解压：</p><pre><code>$ tar xzvf TensorRT-5.0.2.6.Ubuntu-16.04.4.x86_64-gnu.cuda-9.0.cudnn7.3.tar.gz</code></pre><p>解压后，在~/.bashrc中添加环境变量：</p><pre><code>Export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/&lt;your name&gt;/TensorRT-5.0.2.6/lib</code></pre><p>添加之后重新启动Terminal，cd到TensorRT-5.0.2.6/python目录下，安装</p><pre><code>$ pip install tensorrt-5.0.2.6-py2.py3-none-any.whl</code></pre><p>cd到TensorRT-5.0.2.6/uff目录下，安装  </p><pre><code>$ pip install uff-0.5.5-py2.py3-none-any.whl</code></pre><p>cd到TensorRT-5.0.2.6/graphsurgeon目录下，安装  </p><pre><code>pip install graphsurgeon-0.3.2-py2.py3-none-any.whl</code></pre><p>至此，TensorRT就已经安装完成了。下面通过运行一个官方的demo说明TensorRT的使用。</p><h1 id="3、TensorRT的使用"><a href="#3、TensorRT的使用" class="headerlink" title="3、TensorRT的使用"></a>3、TensorRT的使用</h1><p>在官方给出的demo中选择python接口的例子中的uff_ssd，这个例子是对Tensorflow框架训练出的ssd-inception-v2-coco目标检测模型进行优化，然后进行推理。</p><p>cd到TensorRT-5.0.2.6/samples/python/uff_ssd目录，升级cmake至3.8版本以上，并安装依赖：</p><pre><code>pip install -r requirements.txt</code></pre><p>安装完成后编译此项目，依次运行:  </p><pre><code>$ mkdir -p build </code></pre><pre><code>$ cd build</code></pre><pre><code>$ cmake ..</code></pre><pre><code>$ make</code></pre><pre><code>$ cd ..</code></pre><p>（cmake之前需要修改uff-ssd目录下的CMakeLists.txt，将第19和20行分别改为：set-ifndef(TRT-LIB /home/<your-name>/TensorRT-5.0.2.6/lib和set-ifndef(TRT-INCLUDE /home/<your-name>/TensorRT-5.0.2.6/include))）<br>执行detect-objects.py脚本，脚本程序会下载ssd-inception-v2-coco模型，转化为.uff格式，解析模型并且创建inference-engine运行推理。<br>推理结果自动保存到本目录下的image-inferred.jpg，推理时间为23ms。</your-name></your-name></p><p><div align="center"><img src="https://test-1258680748.cos.ap-shanghai.myqcloud.com/TensorRT%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/3.jpg" alt=""></div></p><p><div align="center"><img src="https://test-1258680748.cos.ap-shanghai.myqcloud.com/TensorRT%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/4.jpg" alt=""></div></p>]]></content>
      
      
      <categories>
          
          <category> 高性能计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习推理 </tag>
            
            <tag> nvidia </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MarkDownPad2的下载与安装</title>
      <link href="/2019/02/05/markdownpad2-de-xia-zai-yu-an-zhuang/"/>
      <url>/2019/02/05/markdownpad2-de-xia-zai-yu-an-zhuang/</url>
      
        <content type="html"><![CDATA[<p>Markdown是一种纯文本格式的标记语言。通过使用它简单的标记语法，就可以使普通的文本内容具有一定的格式。<br>MarkdownPad是Windows系统下一款全功能的Markdown编辑器。</p><h1 id="1、下载"><a href="#1、下载" class="headerlink" title="1、下载"></a>1、下载</h1><p>点击<a href="http://markdownpad.com/" target="_blank" rel="noopener">这里</a>进入MarkdownPad的主页面，点击上面菜单栏的Download选项就可以下载MarkdownPad了。下载完成后得到markdownpad2-setup.exe文件。</p><h1 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h1><p>双击下载的文件，选择安装目录，其他的选择默认就好，直至安装完成。</p><h1 id="3、使用之前"><a href="#3、使用之前" class="headerlink" title="3、使用之前"></a>3、使用之前</h1><p>刚安装之后打开MarkdownPad2，开启实时预览，窗口的右半部分可能会出现crashed，并且会弹出HTTP Render error错误提示框。这时关闭提示框，<a href="http://markdownpad.com/download/awesomium_v1.6.6_sdk_win.exe" target="_blank" rel="noopener">下载</a>这个SDK，安装之后重启一下电脑，再打开MarkdownPad2就不会出现上述错误了。</p>]]></content>
      
      
      <categories>
          
          <category> 搭建个人博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/01/29/hello-world/"/>
      <url>/2019/01/29/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
